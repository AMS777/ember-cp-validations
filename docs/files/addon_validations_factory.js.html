<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/validations/factory.js - Ember CP Validations</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700' rel='stylesheet' type='text/css'>
</head>
<body>
    <div class="row">
        <div class="sidebar-container">
            <div id="sidebar">
              <div class="header">
                <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
                  <a href="../">Ember CP Validations</a>
                </h1>
                <form class="navbar-form">
                    <input type="search" class="search-query" placeholder="Search classes/modules...">
                </form>
              </div>
              <ul class="main-nav">
                <li class="section">Modules</li>
                   <li  >
                     <a href="../modules/Home.html">Home</a>
                        <li class="sub "><a href="../modules/Basic Usage.html">Basic Usage</a></li>
                        <li class="sub "><a href="../modules/Advanced Usage.html">Advanced Usage</a></li>
                        <li class="sub "><a href="../modules/I18n Solutions.html">I18n Solutions</a></li>
                   </li>
                   <li  >
                     <a href="../modules/Templating.html">Templating</a>
                   </li>
                   <li  >
                     <a href="../modules/Validations.html">Validations</a>
                   </li>
                   <li  >
                     <a href="../modules/Validators.html">Validators</a>
                   </li>
            
                <li class="section">Classes</li>
                    <li ><a  href="../classes/Base.html">Base</a></li>
                    <li ><a  href="../classes/Belongs To.html">Belongs To</a></li>
                    <li ><a  href="../classes/Collection.html">Collection</a></li>
                    <li ><a  href="../classes/Confirmation.html">Confirmation</a></li>
                    <li ><a  href="../classes/Custom.html">Custom</a></li>
                    <li ><a  href="../classes/Date.html">Date</a></li>
                    <li ><a  href="../classes/Dependent.html">Dependent</a></li>
                    <li ><a  href="../classes/DS Error.html">DS Error</a></li>
                    <li ><a  href="../classes/Error.html">Error</a></li>
                    <li ><a  href="../classes/Exclusion.html">Exclusion</a></li>
                    <li ><a  href="../classes/Factory.html">Factory</a></li>
                    <li ><a  href="../classes/Format.html">Format</a></li>
                    <li ><a  href="../classes/Has Many.html">Has Many</a></li>
                    <li ><a  href="../classes/Inclusion.html">Inclusion</a></li>
                    <li ><a  href="../classes/Length.html">Length</a></li>
                    <li ><a  href="../classes/Messages.html">Messages</a></li>
                    <li ><a  href="../classes/Number.html">Number</a></li>
                    <li ><a  href="../classes/Presence.html">Presence</a></li>
                    <li ><a  href="../classes/Result.html">Result</a></li>
                    <li ><a  href="../classes/ResultCollection.html">ResultCollection</a></li>
              </ul>
            
              <div class="footer">
                <a href="https://github.com/offirgolan/ember-cp-validations" class="github">GitHub</a>
                <p class="version pull-right">v2.6.0</p>
              </div>
            </div>
        </div>
        <div class="content-container">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <form id="options-form" class="form-inline pull-right">
                            Show:
                            <label for="api-show-inherited" class="checkbox">
                                <input type="checkbox" id="api-show-inherited" checked>
                                Inherited
                            </label>
                    
                            <label for="api-show-protected" class="checkbox">
                                <input type="checkbox" id="api-show-protected">
                                Protected
                            </label>
                    
                            <label for="api-show-private" class="checkbox">
                                <input type="checkbox" id="api-show-private">
                                Private
                            </label>
                            <label for="api-show-deprecated" class="checkbox">
                                <input type="checkbox" id="api-show-deprecated">
                                Deprecated
                            </label>
                    
                        </form>
                    
<div class="page-header">
    <h1>addon/validations/factory.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * Copyright 2016, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

import Ember from &#x27;ember&#x27;;
import getOwner from &#x27;ember-getowner-polyfill&#x27;;
import flatten from &#x27;../utils/flatten&#x27;;
import assign from &#x27;../utils/assign&#x27;;
import ValidationResult from &#x27;./result&#x27;;
import ValidationResultCollection from &#x27;./result-collection&#x27;;
import BaseValidator from &#x27;../validators/base&#x27;;
import cycleBreaker from &#x27;../utils/cycle-breaker&#x27;;

const {
  get,
  set,
  run,
  RSVP,
  merge,
  isNone,
  guidFor,
  isEmpty,
  isArray,
  computed,
  makeArray,
  canInvoke,
  getWithDefault,
  A: emberArray
} = Ember;

const {
  Promise
} = RSVP;

const {
  and,
  or,
  not
} = computed;

/**
 * ## Running Manual Validations
 *
 * Although validations are lazily computed, there are times where we might want to force all or
 * specific validations to happen. For this reason we have exposed two methods:
 * - {{#crossLink &quot;Factory/validateSync:method&quot;}}{{/crossLink}}: Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous
 * - {{#crossLink &quot;Factory/validate:method&quot;}}{{/crossLink}}: Will always return a promise and should be used if asynchronous validations are present
 *
 * ## Inspecting Validations
 *
 * All validations can be accessed via the &#x60;validations&#x60; object created on your model/object.
 * Each attribute also has its own validation which has the same properties.
 * An attribute validation can be accessed via &#x60;validations.attrs.&lt;ATTRIBUTE&gt;&#x60; which will return a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * ### Global Validations
 *
 * Global validations exist on the &#x60;validations&#x60; object that resides on the object that is being validated.
 * To see all possible properties, please checkout the docs for {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.isValid&#x27;);
 * model.get(&#x27;validations.errors&#x27;);
 * model.get(&#x27;validations.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 *
 * ### Attribute Validations
 *
 * The &#x60;validations&#x60; object also contains an &#x60;attrs&#x60; object which holds a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}
 * for each attribute specified in your validation rules.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.attrs.username.isValid&#x27;);
 * model.get(&#x27;validations.attrs.password.errors&#x27;);
 * model.get(&#x27;validations.attrs.email.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 *
 * @module Validations
 * @main Validations
 * @class Factory
 */

/**
 * Temporary fix until setOwner polyfill is created
 * https://github.com/rwjblue/ember-getowner-polyfill/issues/1
 */
function setOwner(obj, model) {
  obj = obj || {};
  if(Ember.setOwner) {
    Ember.setOwner(obj, getOwner(model));
  } else {
    obj.container = get(model, &#x27;container&#x27;);
  }
}

/**
 * Top level method that will ultimately return a mixin with all CP validations
 * @method  buildValidations
 * @param  {Object} validations  Validation rules
 * @return {Ember.Mixin}
 */
export default function buildValidations(validations = {}) {
  processDefaultOptions(validations);

  let Validations;

  return Ember.Mixin.create({
    _validationsClass: computed(function() {
      if (!Validations) {
        Validations = createValidationsClass(this._super(), validations);
      }
      return Validations;
    }).readOnly(),
    validations: computed(function() {
      return this.get(&#x27;_validationsClass&#x27;).create({ model: this });
    }).readOnly(),
    validate() {
      return get(this, &#x27;validations&#x27;).validate(...arguments);
    },
    validateSync() {
      return get(this, &#x27;validations&#x27;).validateSync(...arguments);
    },
    destroy() {
      this._super(...arguments);
      get(this, &#x27;validations&#x27;).destroy();
    }
  });
}

/**
 * Validation rules can be created with default options
 * {
 *   description: &#x27;Username&#x27;,
 *   validators: [...]
 * }
 * This method generate the default options pojo, applies it to each validation rule, and flattens the object
 * @method processDefaultOptions
 * @private
 * @param  {Object} validations
 * @return
 */
function processDefaultOptions(validations = {}) {
  var validatableAttrs = Object.keys(validations);

  validatableAttrs.forEach(attribute =&gt; {
    let rules = validations[attribute];
    if(rules &amp;&amp; typeof rules === &#x27;object&#x27; &amp;&amp; isArray(rules.validators)) {
      let options = Object.keys(rules).reduce((o, k) =&gt; {
        if(k !== &#x27;validators&#x27;) {
          o[k] = rules[k];
        }
        return o;
      }, {});
      let validators = rules.validators;
      validators.forEach(v =&gt; v.defaultOptions = options);
      validations[attribute] = validators;
    }
  });
}

/**
 * Creates the validations class that will become &#x60;model.validations&#x60;.
 *   - Setup parent validation inheritance
 *   - Normalize nested keys (i.e. &#x27;details.dob&#x27;) into objects (i.e { details: { dob: validator() }})
 *   - Merge normalized validations with parent
 *   - Create &#x60;attrs&#x60; object with CPs
 *   - Create global CPs (i.e. &#x27;isValid&#x27;, &#x27;messages&#x27;, etc...)
 *
 * @method createValidationsClass
 * @private
 * @param  {Object} inheritedValidationsClass
 * @param  {Object} validations
 * @return {Ember.Object}
 */
function createValidationsClass(inheritedValidationsClass, validations = {}) {
  let validationRules = {};
  let validatableAttributes = Object.keys(validations);

  // Setup validation inheritance
  if(inheritedValidationsClass) {
    let inheritedValidations = inheritedValidationsClass.create();
    validationRules = merge(validationRules, inheritedValidations.get(&#x27;_validationRules&#x27;));
    validatableAttributes = emberArray(inheritedValidations.get(&#x27;validatableAttributes&#x27;).concat(validatableAttributes)).uniq();
  }

  // Normalize nested keys into actual objects and merge them with parent object
  Object.keys(validations).reduce((obj, key) =&gt; {
    assign(obj, key, validations[key]);
    return obj;
  }, validationRules);

  // Create the CPs that will be a part of the &#x60;attrs&#x60; object
  let attrCPs = validatableAttributes.reduce((obj, attribute) =&gt; {
    assign(obj, attribute, createCPValidationFor(attribute, validationRules[attribute]), true);
    return obj;
  }, {});

  // Create the mixin that holds all the top level validation props (isValid, messages, etc)
  const TopLevelProps = createTopLevelPropsMixin(validatableAttributes);

  // Create the &#x60;attrs&#x60; class which will add the current model reference once instantiated
  const Attrs = Ember.Object.extend(attrCPs, {
    init() {
      this._super(...arguments);
      let model = this.get(&#x27;_model&#x27;);

      validatableAttributes.forEach((attribute) =&gt; {
        // Add a reference to the model in the deepest object
        let path = attribute.split(&#x27;.&#x27;);
        let lastObject = get(this, path.slice(0, path.length  - 1).join(&#x27;.&#x27;));
        if(isNone(get(lastObject, &#x27;_model&#x27;))) {
          set(lastObject, &#x27;_model&#x27;, model);
        }
      });
    }
  });

  // Create &#x60;validations&#x60; class
  return Ember.Object.extend(TopLevelProps, {
    model: null,
    attrs: null,
    isValidations: true,

    validatableAttributes: computed(function() {
      return validatableAttributes;
    }).readOnly(),

    // Caches
    _validators: null,
    _debouncedValidations: null,

    // Private
    _validationRules: computed(function() {
      return validationRules;
    }).readOnly(),

    validate,
    validateSync,

    init() {
      this._super(...arguments);
      this.setProperties({
        attrs: Attrs.create({ _model: this.get(&#x27;model&#x27;) }),
        _validators: {},
        _debouncedValidations: {}
      });
    },

    destroy() {
      this._super(...arguments);
      let validatableAttrs = get(this, &#x27;validatableAttributes&#x27;);
      let debouncedValidations = get(this, &#x60;_debouncedValidations&#x60;);

      // Cancel all debounced timers
      validatableAttrs.forEach(attr =&gt; {
        let attrCache = get(debouncedValidations, attr);
        if(!isNone(attrCache)) {
          // Itterate over each attribute and cancel all of its debounced validations
          Object.keys(attrCache).forEach(v =&gt; run.cancel(attrCache[v]));
        }
      });
    }
  });
}

/**
 * CP generator for the given attribute
 * @method createCPValidationFor
 * @private
 * @param  {String} attribute
 * @param  {Array / Object} validations
 * @return {Ember.computed} A computed property which is a ValidationResultCollection
 */
function createCPValidationFor(attribute, validations) {
  var dependentKeys = getCPDependentKeysFor(attribute, validations);
  return computed(...dependentKeys, cycleBreaker(function() {
    var model = get(this, &#x27;_model&#x27;);
    var validators = getValidatorsFor(attribute, model);

    var validationResults = validators.map(validator =&gt; {
      let options = validator.processOptions();
      let debounce = getWithDefault(options, &#x27;debounce&#x27;, 0);
      let disabled = getWithDefault(options, &#x27;disabled&#x27;, false);
      let value;

      if(disabled) {
        value = true;
      } else if(debounce &gt; 0) {
        let cache = getDebouncedValidationsCacheFor(attribute, model);
        // Return a promise and pass the resolve method to the debounce handler
        value = new Promise(resolve =&gt; {
          cache[guidFor(validator)] = run.debounce(validator, debouncedValidate, validator, model, attribute, resolve, debounce, false);
        });
      } else {
        value = validator.validate(get(model, attribute), options, model, attribute);
      }

      return validationReturnValueHandler(attribute, value, model, validator);
    });

    return ValidationResultCollection.create({
      attribute, content: flatten(validationResults)
    });
  })).readOnly();
}

/**
 * Create a mixin that will have all the top level CPs under the validations object.
 * These are computed collections on different properties of each attribute validations CP
 *
 * @method createTopLevelPropsMixin
 * @private
 * @param  {Object} validations
 */
function createTopLevelPropsMixin(validatableAttrs) {
  return Ember.Mixin.create({
    isValid: and(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.isValid&#x60;)).readOnly(),
    isValidating: or(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.isValidating&#x60;)).readOnly(),
    isDirty: or(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.isDirty&#x60;)).readOnly(),
    isAsync: or(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.isAsync&#x60;)).readOnly(),
    isNotValidating: not(&#x27;isValidating&#x27;).readOnly(),
    isInvalid: not(&#x27;isValid&#x27;).readOnly(),
    isTruelyValid: and(&#x27;isValid&#x27;, &#x27;isNotValidating&#x27;).readOnly(),

    messages: computed(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.messages&#x60;), function() {
      return emberArray(flatten(validatableAttrs.map(attr =&gt; get(this, &#x60;attrs.${attr}.messages&#x60;)))).compact();
    }).readOnly(),

    message: computed(&#x27;messages.[]&#x27;, cycleBreaker(function() {
      return get(this, &#x27;messages.0&#x27;);
    })).readOnly(),

    errors: computed(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}.@each.errors&#x60;), function() {
      return emberArray(flatten(validatableAttrs.map(attr =&gt; get(this, &#x60;attrs.${attr}.errors&#x60;)))).compact();
    }).readOnly(),

    error: computed(&#x27;errors.[]&#x27;, cycleBreaker(function() {
      return get(this, &#x27;errors.0&#x27;);
    })).readOnly(),

    _promise: computed(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}._promise&#x60;), function() {
      var promises = [];
      validatableAttrs.forEach((attr) =&gt; {
        var validation = get(this, &#x60;attrs.${attr}&#x60;);
        if (get(validation, &#x27;isAsync&#x27;)) {
          promises.push(get(validation, &#x27;_promise&#x27;));
        }
      });
      return RSVP.Promise.all(flatten(promises));
    }).readOnly()
  });
}

/**
 * CP dependency generator for a give attribute depending on its relationships
 * @method getCPDependentKeysFor
 * @private
 * @param  {String} attribute
 * @param  {Array / Object} validations
 * @return {Array} Unique list of dependencies
 */
function getCPDependentKeysFor(attribute, validations) {
  var dependentKeys = emberArray();
  validations = makeArray(validations);

  dependentKeys.push(&#x60;_model.${attribute}&#x60;);

  validations.forEach((validation) =&gt; {
    let type = validation._type;
    let options = validation.options;

    if (type === &#x27;belongs-to&#x27;) {
      dependentKeys.push(&#x60;${attribute}.isTruelyValid&#x60;);
    } else if (type === &#x27;has-many&#x27;) {
      dependentKeys.push(&#x60;${attribute}.@each.isTruelyValid&#x60;);
    } else if (type === &#x27;ds-error&#x27;) {
      dependentKeys.push(&#x60;_model.errors.${attribute}.[]&#x60;);
    } else if (type === &#x27;confirmation&#x27; &amp;&amp; validation.options.on) {
      dependentKeys.push(&#x60;_model.${validation.options.on}&#x60;);
    } else if (type === &#x27;dependent&#x27;) {
      var dependents = get(validation, &#x27;options.on&#x27;);
      if (!isEmpty(dependents)) {
        dependents.forEach((dependent) =&gt; dependentKeys.push(&#x60;${dependent}.isTruelyValid&#x60;));
      }
    } else if (type === &#x27;collection&#x27; &amp;&amp; (options === true || options.collection === true)) {
      dependentKeys.push(&#x60;_model.${attribute}.[]&#x60;);
    }

    let specifiedDependents = [].concat(getWithDefault(options, &#x27;dependentKeys&#x27;, []), getWithDefault(validation, &#x27;defaultOptions.dependentKeys&#x27;, []));
    specifiedDependents.forEach(d =&gt; {
      dependentKeys.push(&#x60;_model.${d}&#x60;);
    });
  });

  return dependentKeys.uniq();
}

/**
 * Debounce handler for running a validation for the specified options
 * @method debouncedValidate
 * @private
 * @param  {Validator} validator
 * @param  {Unknown} value
 * @param  {Object} options
 * @param  {Object} model
 * @param  {String} attribute
 * @param  {Function} resolve
 */
function debouncedValidate(validator, model, attribute, resolve) {
  resolve(validator.validate(get(model, attribute), validator.processOptions(), model, attribute));
}

/**
 * A handler used to create ValidationResult object from values returned from a validator
 * @method validationReturnValueHandler
 * @private
 * @param  {String} attribute
 * @param  {Unknown} value
 * @param  {Object} model
 * @return {ValidationResult}
 */
function validationReturnValueHandler(attribute, value, model, validator) {
  var result, _promise;

  if (canInvoke(value, &#x27;then&#x27;)) {
    _promise = Promise.resolve(value);
    result = ValidationResult.create({
      attribute, _promise, model,
      _validator: validator
    });
  } else {
    result = ValidationResult.create({
      attribute, model,
      _validator: validator
    });
    result.update(value);
  }

  return result;
}

/**
 * Get validators for the give attribute. If they are not in the cache, then create them.
 * @method getValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function getValidatorsFor(attribute, model) {
  var validators = get(model, &#x60;validations._validators.${attribute}&#x60;);

  if (!isNone(validators)) {
    return validators;
  }

  return createValidatorsFor(attribute, model);
}

/**
 * Get debounced validation cache for the given attribute. If it doesnt exist, create a new one.
 * @method getValidatorCacheFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Map}
 */
function getDebouncedValidationsCacheFor(attribute, model) {
  var debouncedValidations = get(model, &#x60;validations._debouncedValidations&#x60;);

  if (isNone(get(debouncedValidations, attribute))) {
    assign(debouncedValidations, attribute, {});
  }

  return get(debouncedValidations, attribute);
}

/**
 * Create validators for the give attribute and store them in a cache
 * @method createValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function createValidatorsFor(attribute, model) {
  var validations = get(model, &#x27;validations&#x27;);
  var validationRules = makeArray(get(validations, &#x60;_validationRules.${attribute}&#x60;));
  var validatorCache = get(validations, &#x27;_validators&#x27;);
  var owner = getOwner(model);
  var validators = [];
  var validator;

  // We must have an owner to be able to lookup our validators
  if (isNone(owner)) {
    throw new TypeError(&#x60;[ember-cp-validations] ${model.toString()} is missing a container or owner.&#x60;);
  }

  validationRules.forEach((v) =&gt; {
    v.attribute = attribute;
    v.model = model;

    // If validate function exists, that means validator was created with a function so use the base class
    if (v._type === &#x27;function&#x27;) {
      validator = BaseValidator;
      setOwner(v, model);
    } else {
      validator = lookupValidator(owner, v._type);
    }
    validators.push(validator.create(v));
  });

  // Add validators to model instance cache
  assign(validatorCache, attribute, validators);

  return validators;
}

/**
 * Lookup a validators of a specific type on the owner
 * @method lookupValidator
 * @throws {Error} Validator not found
 * @private
 * @param  {Ember.Owner} owner
 * @param  {String} type
 * @return {Class} Validator class or undefined if not found
 */
function lookupValidator(owner, type) {
  var validatorClass = owner._lookupFactory(&#x60;validator:${type}&#x60;);
  if(isNone(validatorClass)) {
    throw new Error(&#x60;[ember-cp-validations] Validator not found of type: ${type}.&#x60;);
  }
  return validatorClass;
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * model.validate({ on: [&#x27;username&#x27;, &#x27;email&#x27;] }).then(({ m, validations }) =&gt; {
 *   validations.get(&#x27;isValid&#x27;); // true or false
 *   validations.get(&#x27;isValidating&#x27;); // false
 *
 *   let usernameValidations = m.get(&#x27;validations.attrs.username&#x27;);
 *   usernameValidations.get(&#x27;isValid&#x27;) // true or false
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method validate
 * @param  {Object}  options
 * @param  {Boolean} async      If &#x60;false&#x60;, will get all validations and will error if an async validations is found.
 *                              If &#x60;true&#x60;, will get all validations and wrap them in a promise hash
 * @return {Promise or Object}  Promise if async is true, object if async is false
 */
function validate(options = {}, async = true) {
  var model = get(this, &#x27;model&#x27;);
  var whiteList = makeArray(options.on);
  var blackList = makeArray(options.excludes);
  var validationResult, value;

  var validationResults = get(this, &#x27;validatableAttributes&#x27;).reduce((v, name) =&gt; {
    if (!isEmpty(blackList) &amp;&amp; blackList.indexOf(name) !== -1) {
      return v;
    }

    if (isEmpty(whiteList) || whiteList.indexOf(name) !== -1) {
      validationResult = get(this, &#x60;attrs.${name}&#x60;);

      // If an async validation is found, throw an error
      if (!async &amp;&amp; get(validationResult, &#x27;isAsync&#x27;)) {
        throw new Error(&#x60;[ember-cp-validations] Synchronous validation failed due to ${name} being an async validation.&#x60;);
      }

      value = get(validationResult, &#x27;value&#x27;);
      v.push(validationResult);
    }
    return v;
  }, []);

  var validationResultsCollection = ValidationResultCollection.create({
    content: validationResults
  });

  var resultObject = {
    model,
    validations: validationResultsCollection
  };

  if (async) {
    if (get(validationResultsCollection, &#x27;isAsync&#x27;)) {
      resultObject.promise = get(validationResultsCollection, &#x27;value&#x27;);
    }
    return RSVP.hash(resultObject);
  }

  return resultObject;
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * const { m, validations } = model.validateSync();
 * validations.get(&#x27;isValid&#x27;) // true or false
 * &#x60;&#x60;&#x60;
 * @method validateSync
 * @param  {Object}  options
 * @return {Object}
 */
function validateSync(options) {
  return this.validate(options, false);
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
