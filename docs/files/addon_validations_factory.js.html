<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/validations/factory.js - Ember CP Validations</title>
    <meta name="description" content="Ember computed property based validations">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    
</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="../" class="navbar-brand">
            <img src="../assets/img/ember-logo.png" alt="">
            <span>CP Validations</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/offirgolan/ember-cp-validations" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="https://github.com/offirgolan/ember-cp-validations/commits/v3.0.0-beta.6" target="_blank">
                                  Tag: v3.0.0-beta.6
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/Templating.html">Templating</a>
                                                    <li class="sub"><a href="../modules/V-Get Helper.html">V-Get Helper</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Usage.html">Usage</a>
                                                    <li class="sub"><a href="../modules/Basic.html">Basic</a></li>
                                                    <li class="sub"><a href="../modules/Advanced.html">Advanced</a></li>
                                                    <li class="sub"><a href="../modules/I18n Solutions.html">I18n Solutions</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Validations.html">Validations</a>
                                                    <li class="sub"><a href="../modules/Accessing Validations.html">Accessing Validations</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Validators.html">Validators</a>
                                                    <li class="sub"><a href="../modules/Common Options.html">Common Options</a></li>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/Alias.html">Alias</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Base.html">Base</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Belongs To.html">Belongs To</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Collection.html">Collection</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Confirmation.html">Confirmation</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Custom.html">Custom</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Date.html">Date</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Dependent.html">Dependent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DS Error.html">DS Error</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Error.html">Error</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Exclusion.html">Exclusion</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Factory.html">Factory</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Format.html">Format</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Has Many.html">Has Many</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Inclusion.html">Inclusion</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Inline.html">Inline</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Length.html">Length</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Messages.html">Messages</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Number.html">Number</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Presence.html">Presence</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Result.html">Result</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ResultCollection.html">ResultCollection</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i> addon/validations/factory.js File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * Copyright 2016, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

import Ember from &#x27;ember&#x27;;
import getOwner from &#x27;ember-getowner-polyfill&#x27;;
import flatten from &#x27;../utils/flatten&#x27;;
import assign from &#x27;../utils/assign&#x27;;
import ValidationResult from &#x27;./result&#x27;;
import ValidationResultCollection from &#x27;./result-collection&#x27;;
import BaseValidator from &#x27;../validators/base&#x27;;
import cycleBreaker from &#x27;../utils/cycle-breaker&#x27;;
import shouldCallSuper from &#x27;../utils/should-call-super&#x27;;
import { isDsModel, isValidatable, isPromise } from &#x27;../utils/utils&#x27;;

const {
  get,
  set,
  run,
  RSVP,
  isNone,
  guidFor,
  isEmpty,
  isArray,
  computed,
  makeArray,
  getWithDefault,
  A: emberArray
} = Ember;

const merge = Ember.assign || Ember.merge;

const {
  Promise
} = RSVP;

/**
 * ## Running Manual Validations
 *
 * Although validations are lazily computed, there are times where we might want to force all or
 * specific validations to happen. For this reason we have exposed three methods:
 *
 * - {{#crossLink &quot;Factory/validateSync:method&quot;}}{{/crossLink}}: Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous
 * - {{#crossLink &quot;Factory/validate:method&quot;}}{{/crossLink}}: Will always return a promise and should be used if asynchronous validations are present
 * - {{#crossLink &quot;Factory/validateAttribute:method&quot;}}{{/crossLink}}: A functional approach to valididating an attribute without changing its state
 *
 * @module Validations
 * @main Validations
 */

/**
 * All validations can be accessed via the &#x60;validations&#x60; object created on your model/object.
 * Each attribute also has its own validation which has the same properties.
 * An attribute validation can be accessed via &#x60;validations.attrs.&lt;ATTRIBUTE&gt;&#x60; which will return a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * ### Global Validations
 *
 * Global validations exist on the &#x60;validations&#x60; object that resides on the object that is being validated.
 * To see all possible properties, please checkout the docs for {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.isValid&#x27;);
 * model.get(&#x27;validations.errors&#x27;);
 * model.get(&#x27;validations.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 *
 * ### Attribute Validations
 *
 * The &#x60;validations&#x60; object also contains an &#x60;attrs&#x60; object which holds a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}
 * for each attribute specified in your validation rules.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.attrs.username.isValid&#x27;);
 * model.get(&#x27;validations.attrs.password.errors&#x27;);
 * model.get(&#x27;validations.attrs.email.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 * @module Validations
 * @submodule Accessing Validations
 */

/**
 * @module Validations
 * @class Factory
 */

/**
 * Top level method that will ultimately return a mixin with all CP validations
 *
 * @method  buildValidations
 * @param  {Object} validations  Validation rules
 * @return {Ember.Mixin}
 */
export
default

function buildValidations(validations = {}, globalOptions = {}) {
  normalizeOptions(validations, globalOptions);

  let Validations, validationMixinCount;

  const ValidationsMixin = Ember.Mixin.create({
    init() {
      this._super(...arguments);

      // Count number of mixins to bypass super check if there is more than 1
      this.__validationsMixinCount__ = this.__validationsMixinCount__ || 0;
      validationMixinCount = ++this.__validationsMixinCount__;
    },
    __validationsClass__: computed(function () {
      if (!Validations) {
        let inheritedClass;
        if(shouldCallSuper(this, &#x27;__validationsClass__&#x27;) || validationMixinCount &gt; 1) {
          inheritedClass = this._super();
        }

        Validations = createValidationsClass(inheritedClass, validations, this);
      }
      return Validations;
    }).readOnly(),
    validations: computed(function () {
      return this.get(&#x27;__validationsClass__&#x27;).create({
        model: this
      });
    }).readOnly(),
    validate() {
      return get(this, &#x27;validations&#x27;).validate(...arguments);
    },
    validateSync() {
      return get(this, &#x27;validations&#x27;).validateSync(...arguments);
    },
    validateAttribute() {
      return get(this, &#x27;validations&#x27;).validateAttribute(...arguments);
    },
    destroy() {
      this._super(...arguments);
      get(this, &#x27;validations&#x27;).destroy();
    }
  });

  // Label mixin under a named scope for Ember Inspector
  ValidationsMixin[Ember.NAME_KEY] = &#x27;Validations&#x27;;

  return ValidationsMixin;
}

/**
 * Validation rules can be created with default and global options
 * {
 *   description: &#x27;Username&#x27;,
 *   validators: [...]
 * }
 *
 * This method generate the default options pojo, applies it to each validation rule, and flattens the object
 *
 * @method normalizeOptions
 * @private
 * @param  {Object} validations
 * @return
 */
function normalizeOptions(validations = {}, globalOptions = {}) {
  const validatableAttrs = Object.keys(validations);

  validatableAttrs.forEach(attribute =&gt; {
    const rules = validations[attribute];

    if (rules &amp;&amp; typeof rules === &#x27;object&#x27; &amp;&amp; isArray(rules.validators)) {
      const options = Object.keys(rules).reduce((o, k) =&gt; {
        if (k !== &#x27;validators&#x27;) {
          o[k] = rules[k];
        }
        return o;
      }, {});

      const validators = rules.validators;

      validators.forEach(v =&gt; {
        v.defaultOptions = options;
      });
      validations[attribute] = validators;
    }
    validations[attribute] = makeArray(validations[attribute]);
    validations[attribute].forEach(v =&gt; {
      v.globalOptions = globalOptions;
    });
  });
}

/**
 * Creates the validations class that will become &#x60;model.validations&#x60;.
 *   - Setup parent validation inheritance
 *   - Normalize nested keys (i.e. &#x27;details.dob&#x27;) into objects (i.e { details: { dob: validator() }})
 *   - Merge normalized validations with parent
 *   - Create global CPs (i.e. &#x27;isValid&#x27;, &#x27;messages&#x27;, etc...)
 *
 * @method createValidationsClass
 * @private
 * @param  {Object} inheritedValidationsClass
 * @param  {Object} validations
 * @param  {Object} model
 * @return {Ember.Object}
 */
function createValidationsClass(inheritedValidationsClass, validations, model) {
  let validationRules = {};
  let validatableAttributes = Object.keys(validations);

  // Setup validation inheritance
  if (inheritedValidationsClass &amp;&amp; inheritedValidationsClass.__isCPValidationsClass__) {
    const inheritedValidations = inheritedValidationsClass.create();

    validationRules = merge(validationRules, inheritedValidations.get(&#x27;_validationRules&#x27;));
    validatableAttributes = emberArray(inheritedValidations.get(&#x27;validatableAttributes&#x27;).concat(validatableAttributes)).uniq();
  }

  // Normalize nested keys into actual objects and merge them with parent object
  Object.keys(validations).reduce((obj, key) =&gt; {
    assign(obj, key, validations[key]);
    return obj;
  }, validationRules);

  // Create the mixin that holds all the top level validation props (isValid, messages, etc)
  const TopLevelProps = createTopLevelPropsMixin(validatableAttributes);

  // Create the &#x60;attrs&#x60; class which will add the current model reference once instantiated
  const AttrsClass = createAttrsClass(validatableAttributes, validationRules, model);

  // Create &#x60;validations&#x60; class
  const ValidationsClass = Ember.Object.extend(TopLevelProps, {
    model: null,
    attrs: null,
    isValidations: true,

    validatableAttributes: computed(function () {
      return validatableAttributes;
    }).readOnly(),

    // Caches
    _validators: null,
    _debouncedValidations: null,

    // Private
    _validationRules: computed(function () {
      return validationRules;
    }).readOnly(),

    validate,
    validateSync,
    validateAttribute,

    init() {
      this._super(...arguments);
      this.setProperties({
        attrs: AttrsClass.create({
          _model: this.get(&#x27;model&#x27;)
        }),
        _validators: {},
        _debouncedValidations: {}
      });
    },

    destroy() {
      this._super(...arguments);
      const validatableAttrs = get(this, &#x27;validatableAttributes&#x27;);
      const debouncedValidations = get(this, &#x27;_debouncedValidations&#x27;);

      // Initiate attrs destroy to cleanup any remaining model references
      this.get(&#x27;attrs&#x27;).destroy();

      // Cancel all debounced timers
      validatableAttrs.forEach(attr =&gt; {
        const attrCache = get(debouncedValidations, attr);

        if (!isNone(attrCache)) {
          // Itterate over each attribute and cancel all of its debounced validations
          Object.keys(attrCache).forEach(v =&gt; run.cancel(attrCache[v]));
        }
      });
    }
  });

  ValidationsClass.reopenClass({
    __isCPValidationsClass__: true
  });

  return ValidationsClass;
}

/**
 * Creates the &#x60;attrs&#x60; class which holds all the CP logic
 *
 * &#x60;&#x60;&#x60;javascript
 * model.get(&#x27;validations.attrs.username&#x27;);
 * model.get(&#x27;validations.attrs.nested.object.attribute&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @method createAttrsClass
 * @private
 * @param  {Object} validatableAttributes
 * @param  {Object} validationRules
 * @param  {Object} model
 * @return {Ember.Object}
 */
function createAttrsClass(validatableAttributes, validationRules, model) {

  // Create the CPs once per Class, not instance
  const cpMap = validatableAttributes.reduce((map, attribute) =&gt; {
    map[attribute] = createCPValidationFor(attribute, model, get(validationRules, attribute));
    return map;
  }, {});

  return Ember.Object.extend({
    init() {
      this._super(...arguments);

      const _model = this.get(&#x27;_model&#x27;);

      /*
        Assign the CPs to this object
        TODO: This runs multiple nested defineProperty calls PER INSTANCE which
              can be seriously hinder perfomance.

        The reason for this is that nested validation CPs must be created in their
        own Ember.Object instance and then setup with the correct model reference.
       */

      validatableAttributes.forEach(attribute =&gt; {
        assign(this, attribute, cpMap[attribute], true);
      });

      // Add a reference to the model in each nested object
      validatableAttributes.forEach(attribute =&gt; {
        const path = attribute.split(&#x27;.&#x27;);
        const lastObject = get(this, path.slice(0, path.length - 1).join(&#x27;.&#x27;));

        if (isNone(get(lastObject, &#x27;_model&#x27;))) {
          set(lastObject, &#x27;_model&#x27;, _model);
        }
      });
    },

    destroy() {
      this._super(...arguments);

      // Remove model reference from each nested object
      validatableAttributes.forEach(attribute =&gt; {
        const path = attribute.split(&#x27;.&#x27;);
        const lastObject = get(this, path.slice(0, path.length - 1).join(&#x27;.&#x27;));

        if (!isNone(get(lastObject, &#x27;_model&#x27;))) {
          set(lastObject, &#x27;_model&#x27;, null);
        }
      });
    }
  });
}

/**
 * CP generator for the given attribute
 *
 * @method createCPValidationFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model         Since the CPs are created once per class on the first initialization,
 *                                this is the first model that was instantiated
 * @param  {Array} validations
 * @return {Ember.ComputedProperty} A computed property which is a ValidationResultCollection
 */
function createCPValidationFor(attribute, model, validations) {
  const dependentKeys = getCPDependentKeysFor(attribute, model, validations);

  return computed(...dependentKeys, cycleBreaker(function () {
    const model = get(this, &#x27;_model&#x27;);
    const validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];

    const validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) =&gt; {
      const debounce = getWithDefault(options, &#x27;debounce&#x27;, 0);

      if (debounce &gt; 0) {
        const cache = getDebouncedValidationsCacheFor(attribute, model);

        // Return a promise and pass the resolve method to the debounce handler
        return new Promise(resolve =&gt; {
          cache[guidFor(validator)] = run.debounce(validator, debouncedValidate, validator, model, attribute, resolve, debounce, false);
        });
      } else {
        return validator.validate(validator.getValue(), options, model, attribute);
      }
    });

    return ValidationResultCollection.create({ attribute, content:  validationResults });
  })).readOnly();
}

/**
 * Generates the validation results for a given attribute and validators. If a
 * given validator should be validated, it calls upon the validate callback to retrieve
 * the result.
 *
 * @method generateValidationResultsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @param  {Array} validators
 * @param  {Function} validate
 * @return {Array}
 */
function generateValidationResultsFor(attribute, model, validators, validate) {
  let isModelValidatable = isValidatable(model);
  let isInvalid = false;
  let value, result;

  return validators.map(validator =&gt; {
    const options = get(validator, &#x27;options&#x27;).copy();
    const isWarning = getWithDefault(options, &#x27;isWarning&#x27;, false);
    const disabled = getWithDefault(options, &#x27;disabled&#x27;, false);
    const lazy = getWithDefault(options, &#x27;lazy&#x27;, true);

    if(disabled || (lazy &amp;&amp; isInvalid) || !isModelValidatable) {
      value = true;
    } else {
      value = validate(validator, options, model, attribute);
    }

    result = validationReturnValueHandler(attribute, value, model, validator);

    /*
      If the current result is invalid, the rest of the validations do not need to be
      triggered (if lazy) since the attribute is already in an invalid state.
     */
    if(!isInvalid &amp;&amp; !isWarning &amp;&amp; get(result, &#x27;isInvalid&#x27;)) {
      isInvalid = true;
    }

    return result;
  });
}

/**
 * Create a mixin that will have all the top level CPs under the validations object.
 * These are computed collections on different properties of each attribute validations CP
 *
 * @method createTopLevelPropsMixin
 * @private
 * @param  {Object} validations
 */
function createTopLevelPropsMixin(validatableAttrs) {
  // Expose the following properties as public APIs via readOnly aliases
  const aliases = [
    &#x27;isWarning&#x27;,
    &#x27;isValid&#x27;,
    &#x27;isValidating&#x27;,
    &#x27;isDirty&#x27;,
    &#x27;isAsync&#x27;,
    &#x27;isNotValidating&#x27;,
    &#x27;isInvalid&#x27;,
    &#x27;isTruelyValid&#x27;,
    &#x27;messages&#x27;,
    &#x27;message&#x27;,
    &#x27;warningMessages&#x27;,
    &#x27;warningMessage&#x27;,
    &#x27;warnings&#x27;,
    &#x27;warning&#x27;,
    &#x27;errors&#x27;,
    &#x27;error&#x27;,
    &#x27;_promise&#x27;
  ];

  const topLevelProps = aliases.reduce((props, alias) =&gt; {
    props[alias] = computed.readOnly(&#x60;__attrsResultCollection__.${alias}&#x60;);
    return props;
  }, {});

  return Ember.Mixin.create(topLevelProps, {
    /*
      Dedupe logic by creating a top level ResultCollection for all attr&#x27;s ResultCollections
     */
    __attrsResultCollection__: computed(...validatableAttrs.map(attr =&gt; &#x60;attrs.${attr}&#x60;), function () {
      return ValidationResultCollection.create({
        content: validatableAttrs.map(attr =&gt; get(this, &#x60;attrs.${attr}&#x60;))
      });
    }).readOnly()
  });
}

/**
 * CP dependency generator for a give attribute depending on its relationships
 *
 * @method getCPDependentKeysFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model         Since the CPs are created once per class on the first initialization,
 *                                this is the first model that was instantiated
 * @param  {Array} validations
 * @return {Array} Unique list of dependencies
 */
function getCPDependentKeysFor(attribute, model, validations) {
  const owner = getOwner(model);

  let dependentKeys = validations.map(validation =&gt; {
    const type = validation._type;
    const options = validation.options;
    const Validator = type === &#x27;function&#x27; ? BaseValidator : lookupValidator(owner, type);
    const baseDependents = BaseValidator.getDependentsFor(attribute, options) || [];
    const dependents = Validator.getDependentsFor(attribute, options) || [];

    const specifiedDependents = [].concat(
      getWithDefault(options, &#x27;dependentKeys&#x27;, []),
      getWithDefault(validation, &#x27;defaultOptions.dependentKeys&#x27;, []),
      getWithDefault(validation, &#x27;globalOptions.dependentKeys&#x27;, [])
    );

    // Extract dependentKeys from option CPs
    const cpDependents = [].concat(
      extractOptionsDependentKeys(options),
      extractOptionsDependentKeys(get(validation, &#x27;defaultOptions&#x27;)),
      extractOptionsDependentKeys(get(validation, &#x27;globalOptions&#x27;))
    );

    return baseDependents.concat(
      dependents,
      cpDependents,
      specifiedDependents
    );
  });

  dependentKeys = flatten(dependentKeys);

  dependentKeys.push(&#x60;model.${attribute}&#x60;);

  if(isDsModel(model)) {
    dependentKeys.push(&#x60;model.isDeleted&#x60;);
  }

  dependentKeys = dependentKeys.map(d =&gt; {
    return d.split(&#x27;.&#x27;)[0] === &#x27;model&#x27; ? &#x27;_&#x27; + d : d;
  });

  return emberArray(dependentKeys).uniq();
}

/**
 * Extract all dependentKeys from any property that is a CP
 *
 * @method extractOptionsDependentKeys
 * @private
 * @param  {Object} options
 * @return {Array}  dependentKeys
 */
function extractOptionsDependentKeys(options) {
  if(options &amp;&amp; typeof options === &#x27;object&#x27;) {
    return Object.keys(options).reduce((arr, key) =&gt; {
      let option = options[key];

      if(option &amp;&amp; typeof option === &#x27;object&#x27; &amp;&amp; option.isDescriptor) {
        return arr.concat(option._dependentKeys || []);
      }

      return arr;
    }, []);
  }

  return [];
}

/**
 * Debounce handler for running a validation for the specified options
 *
 * @method debouncedValidate
 * @private
 * @param  {Validator} validator
 * @param  {Mixed} value
 * @param  {Object} options
 * @param  {Object} model
 * @param  {String} attribute
 * @param  {Function} resolve
 */
function debouncedValidate(validator, model, attribute, resolve) {
  const options = get(validator, &#x27;options&#x27;).copy();
  const value = validator.getValue();

  resolve(validator.validate(value, options, model, attribute));
}

/**
 * A handler used to create ValidationResult object from values returned from a validator
 *
 * @method validationReturnValueHandler
 * @private
 * @param  {String} attribute
 * @param  {Mixed} value
 * @param  {Object} model
 * @return {ValidationResult}
 */
function validationReturnValueHandler(attribute, value, model, validator) {
  let result;

  if (isPromise(value)) {
    result = ValidationResult.create({
      attribute,
      _promise: Promise.resolve(value),
      model,
      _validator: validator
    });
  } else {
    result = ValidationResult.create({
      attribute,
      model,
      _validator: validator
    });
    result.update(value);
  }

  return result;
}

/**
 * Get validators for the give attribute. If they are not in the cache, then create them.
 *
 * @method getValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function getValidatorsFor(attribute, model) {
  const validators = get(model, &#x60;validations._validators.${attribute}&#x60;);

  if (!isNone(validators)) {
    return validators;
  }

  return createValidatorsFor(attribute, model);
}

/**
 * Get debounced validation cache for the given attribute. If it doesnt exist, create a new one.
 *
 * @method getValidatorCacheFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Map}
 */
function getDebouncedValidationsCacheFor(attribute, model) {
  const debouncedValidations = get(model, &#x27;validations._debouncedValidations&#x27;);

  if (isNone(get(debouncedValidations, attribute))) {
    assign(debouncedValidations, attribute, {});
  }

  return get(debouncedValidations, attribute);
}

/**
 * Create validators for the give attribute and store them in a cache
 *
 * @method createValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function createValidatorsFor(attribute, model) {
  const validations = get(model, &#x27;validations&#x27;);
  const validationRules = makeArray(get(validations, &#x60;_validationRules.${attribute}&#x60;));
  const validatorCache = get(validations, &#x27;_validators&#x27;);
  const owner = getOwner(model);
  const validators = [];
  let validator;

  // We must have an owner to be able to lookup our validators
  if (isNone(owner)) {
    throw new TypeError(&#x60;[ember-cp-validations] ${model.toString()} is missing a container or owner.&#x60;);
  }

  validationRules.forEach(v =&gt; {
    v.attribute = attribute;
    v.model = model;

    // If validate function exists, that means validator was created with a function so use the base class
    if (v._type === &#x27;function&#x27;) {
      validator = BaseValidator.create(owner.ownerInjection(), v);
    } else {
      validator = lookupValidator(owner, v._type).create(v);
    }
    validators.push(validator);
  });

  // Add validators to model instance cache
  assign(validatorCache, attribute, validators);

  return validators;
}

/**
 * Lookup a validators of a specific type on the owner
 *
 * @method lookupValidator
 * @throws {Error} Validator not found
 * @private
 * @param  {Ember.Owner} owner
 * @param  {String} type
 * @return {Class} Validator class or undefined if not found
 */
function lookupValidator(owner, type) {
  const validatorClass = owner._lookupFactory(&#x60;validator:${type}&#x60;);

  if (isNone(validatorClass)) {
    throw new Error(&#x60;[ember-cp-validations] Validator not found of type: ${type}.&#x60;);
  }
  return validatorClass;
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * model.validate({ on: [&#x27;username&#x27;, &#x27;email&#x27;] }).then(({ m, validations }) =&gt; {
 *   validations.get(&#x27;isValid&#x27;); // true or false
 *   validations.get(&#x27;isValidating&#x27;); // false
 *
 *   let usernameValidations = m.get(&#x27;validations.attrs.username&#x27;);
 *   usernameValidations.get(&#x27;isValid&#x27;) // true or false
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method validate
 * @param  {Object}  options
 * @param  {Boolean} async      If &#x60;false&#x60;, will get all validations and will error if an async validations is found.
 *                              If &#x60;true&#x60;, will get all validations and wrap them in a promise hash
 * @return {Promise or Object}  Promise if async is true, object if async is false
 */
function validate(options = {}, async = true) {
  const model = get(this, &#x27;model&#x27;);
  const whiteList = makeArray(options.on);
  const blackList = makeArray(options.excludes);

  const validationResults = get(this, &#x27;validatableAttributes&#x27;).reduce((v, name) =&gt; {
    if (!isEmpty(blackList) &amp;&amp; blackList.indexOf(name) !== -1) {
      return v;
    }

    if (isEmpty(whiteList) || whiteList.indexOf(name) !== -1) {
      const validationResult = get(this, &#x60;attrs.${name}&#x60;);

      // If an async validation is found, throw an error
      if (!async &amp;&amp; get(validationResult, &#x27;isAsync&#x27;)) {
        throw new Error(&#x60;[ember-cp-validations] Synchronous validation failed due to ${name} being an async validation.&#x60;);
      }

      v.push(validationResult);
    }
    return v;
  }, []);

  const resultCollection = ValidationResultCollection.create({
    content: validationResults
  });

  const resultObject = {
    model,
    validations: resultCollection
  };

  if (async) {
    if (get(resultCollection, &#x27;isAsync&#x27;)) {
      return RSVP.allSettled(makeArray(get(resultCollection, &#x27;_promise&#x27;))).then(() =&gt; resultObject);
    }
    return Promise.resolve(resultObject);
  }

  return resultObject;
}

/**
 * A functional approach to check if a given attribute on a model is valid independently of the
 * model attribute&#x27;s validations. This method will always return a promise which will then resolve
 * to a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * &#x60;&#x60;&#x60;javascript
 * model.validateAttribute(&#x27;username&#x27;, &#x27;offirgolan&#x27;).then(({ m, validations }) =&gt; {
 *   validations.get(&#x27;isValid&#x27;); // true or false
 *   validations.get(&#x27;isValidating&#x27;); // false
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method validateAttribute
 * @param  {String}   attribute
 * @param  {Mixed}  value
 * @return {Promise}
 * @async
 */
function validateAttribute(attribute, value) {
  const model = get(this, &#x27;model&#x27;);
  const validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];

  const validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) =&gt; {
    return validator.validate(value, options, model, attribute);
  });

  const validations = ValidationResultCollection.create({
    attribute,
    content: flatten(validationResults)
  });

  const result = { model, validations };

  return Promise.resolve(get(validations, &#x27;isAsync&#x27;) ? get(validations, &#x27;_promise&#x27;).then(() =&gt; result) : result);
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * const { m, validations } = model.validateSync();
 * validations.get(&#x27;isValid&#x27;) // true or false
 * &#x60;&#x60;&#x60;
 *
 * @method validateSync
 * @param  {Object}  options
 * @return {Object}
 */
function validateSync(options) {
  return this.validate(options, false);
}

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
